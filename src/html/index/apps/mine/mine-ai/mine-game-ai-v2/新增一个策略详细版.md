1. 遍历所有带数字的节点，该数字周围存在未揭开的格子时，需要进行分析
2. 分析出所有叠加区域只能包含指定雷数，叠加区域包含多个节点，用一个对象表示一个叠加区域 { nodes: [], count: 0}，同时用一个数组保存所有的叠加区域，同时用一个map，key为节点坐标，value为该节点所在的叠加区域数组，因为一个节点可能属于多个叠加区域
3. 再次遍历所有带数字的节点，找到该节点所有的未揭开格子，遍历未揭开格子，分成两部分，一部分是叠加区域，一部分是除去叠加区域的部分
4. 分析：该节点周围有8个格子，只需要对未揭开的格子分析
4. 分析1：如果非叠加区域的格子数加上叠加区域的雷数等于该节点的数字，则将非叠加区域的格子全部标记为雷；
5. 分析2：如果叠加区域的雷数等于该节点的数字，则将非叠加区域的格子全部标记为非雷；



### 设计文档：扫雷游戏逻辑推理算法

---

#### **1. 概述**
本文档详细描述了一种扫雷游戏中的逻辑推理算法，旨在通过分析已揭开的数字节点及其周围未揭开的格子，推断出安全格子或雷的位置。该方案通过识别叠加区域（多个数字节点共享的未揭开区域）并应用约束条件进行推理。

---

#### **2. 核心逻辑**

##### **2.1 定义与数据结构**
- **数字节点**：已揭开的单元格，且其 `adjacentMines > 0`。
- **叠加区域**：多个数字节点的未揭开区域的交集，格式为：
  ```javascript
  { nodes: [Cell], count: number } // count 表示该区域至少/至多包含的雷数
  ```
- **网格状态**：由 `gridState` 表示，每个单元格包含 `isMine`、`revealed`、`flagged` 等属性。

##### **2.2 算法流程**
1. **遍历所有数字节点**：
   - 对每个数字节点，检查其周围未揭开的格子。
   - 若这些格子与其他数字节点的未揭开格子重叠，则形成叠加区域。

2. **构建叠加区域列表**：
   - 每个叠加区域包含共享的未揭开格子和雷数约束（基于关联的数字节点）。

3. **二次遍历数字节点**：
   - 对每个数字节点的未揭开格子，分割为 **叠加区域** 和 **非叠加区域**。
   - 应用以下两条规则：
     - **规则1**：若 `非叠加区域的格子数 + 叠加区域的雷数 = 数字节点值`，则非叠加区域的格子全为雷。
     - **规则2**：若 `叠加区域的雷数 = 数字节点值`，则非叠加区域的格子全为非雷。

---

#### **3. 针对行3列4的推理分析**

##### **3.1 上下文分析**
- **目标单元格**：行3列4（`gridState[3][4]`），未揭开且未被标记。
- **周围关键节点**：
  - 行3列2（`gridState[3][2]`，值2，剩余雷数1）。
  - 行4列2（`gridState[4][2]`，值3，剩余雷数1）。
  - 行5列3（`gridState[5][3]`，雷但未被标记）。

##### **3.2 叠加区域分析**
1. **行3列2的未揭开区域**：
   - 格子：行2列3、行3列3、行4列3。
   - 剩余雷数：1（已标记行3列1的雷）。

2. **行4列2的未揭开区域**：
   - 格子：行3열3、行4열3、行4열4。
   - 剩余雷数：1（已标记行3列1和行5列3的雷）。

3. **叠加区域**：
   - 行3열3、行4열3（同时属于两个节点的未揭开区域）。
   - 约束：两区域的雷数需同时满足两个节点的剩余雷数。

##### **3.3 应用规则**
1. **对行4列2应用规则2**：
   - 假设叠加区域（行3열3、行4열3）的雷数 = 剩余雷数1。
   - 非叠加区域（行4열4）的雷数 = 0。
   - **结论**：行4열4为非雷。

2. **对行3列2应用规则1**：
   - 非叠加区域（行2열3）的格子数1 + 叠加区域雷数0 = 剩余雷数1。
   - **结论**：行2열3为雷。

##### **3.4 推导行3열4的安全性**
- 行3열4的周围雷分布：
  - 行2열3（雷）、行4열4（非雷）。
  - 其他格子（行3열3、行4열3）为非雷。
- **结论**：行3열4周围仅1个雷（行2열3），但根据游戏数据，其 `isMine: false`，可安全揭开。

---

#### **4. 方案验证**
- **正确性**：通过叠加区域分析，成功推导出行4열4和行2열3的雷状态，进而排除行3열4为雷。
- **局限性**：依赖玩家标记的准确性，未标记的雷（如行0열3）可能导致推理不完整。

---

#### **5. 实现细节**
- **遍历优化**：使用优先队列处理高概率推理节点。
- **动态更新**：每次标记或揭开后重新计算叠加区域。
- **边界处理**：忽略越界的格子索引。

---

#### **6. 结论**
本方案通过系统性分析叠加区域和约束条件，能有效识别安全格子（如行3列4）和雷的位置，适用于中等复杂度的扫雷场景。